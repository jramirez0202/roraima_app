#!/bin/bash -e

# ============================================
# DOCKER ENTRYPOINT - RutiService App
# ============================================
# Este script se ejecuta ANTES de iniciar la aplicaci√≥n Rails.
# Prepara el entorno: espera a que las dependencias (Postgres, Redis)
# est√©n listas y ejecuta migraciones pendientes.
#
# FLUJO:
# 1. Docker inicia el contenedor
# 2. ENTRYPOINT ejecuta este script
# 3. Script espera a Postgres/Redis
# 4. Script ejecuta rails db:prepare (si es servidor)
# 5. CMD ejecuta el comando final (rails server, bash, etc.)
#
# USO:
# - Normal: docker compose up (ejecuta rails server)
# - Custom: docker compose run web bash (ejecuta bash en lugar de server)
# ============================================

# ------------------------------------------
# FUNCI√ìN: Esperar a PostgreSQL
# ------------------------------------------
# Intenta conectarse a PostgreSQL cada 1 segundo, m√°ximo 30 intentos.
# Si no puede conectarse despu√©s de 30 segundos, falla y detiene el contenedor.

wait_for_postgres() {
  echo ""
  echo "================================================"
  echo "‚è≥ Esperando a que PostgreSQL est√© listo..."
  echo "================================================"

  # Extraer el host de DATABASE_URL (formato: postgresql://user:pass@host:port/db)
  DB_HOST=$(echo "$DATABASE_URL" | sed -n 's|.*@\([^:]*\):.*|\1|p')

  # Intentar conectar 30 veces usando pg_isready (mucho m√°s r√°pido que rails runner)
  for i in {1..30}; do
    if pg_isready -h "$DB_HOST" -U postgres &> /dev/null; then
      echo "‚úÖ PostgreSQL est√° listo y aceptando conexiones"
      return 0  # √âxito, salir de la funci√≥n
    fi

    # Si llegamos aqu√≠, fall√≥ el intento
    echo "   Intento $i/30... PostgreSQL a√∫n no est√° listo"
    sleep 1  # Esperar 1 segundo antes del siguiente intento
  done

  # Si salimos del loop sin return, significa que fallaron los 30 intentos
  echo ""
  echo "‚ùå ERROR CR√çTICO: PostgreSQL no respondi√≥ despu√©s de 30 segundos"
  echo "   Verifica que el servicio postgres est√© corriendo:"
  echo "   docker compose ps postgres"
  echo ""
  exit 1  # Salir con c√≥digo de error (detiene el contenedor)
}

# ------------------------------------------
# FUNCI√ìN: Esperar a Redis
# ------------------------------------------
# Similar a wait_for_postgres, pero para Redis.
# Solo se ejecuta si REDIS_URL est√° configurado.

wait_for_redis() {
  # Verificar si REDIS_URL est√° definido
  if [ -z "$REDIS_URL" ]; then
    echo ""
    echo "‚ö†Ô∏è  REDIS_URL no est√° configurado, omitiendo verificaci√≥n de Redis"
    echo "   (Sidekiq no funcionar√° sin Redis)"
    return 0
  fi

  echo ""
  echo "================================================"
  echo "‚è≥ Esperando a que Redis est√© listo..."
  echo "================================================"

  # Extraer host y puerto de REDIS_URL (formato: redis://host:port/db)
  REDIS_HOST=$(echo "$REDIS_URL" | sed -n 's|redis://\([^:]*\):.*|\1|p')
  REDIS_PORT=$(echo "$REDIS_URL" | sed -n 's|redis://[^:]*:\([0-9]*\).*|\1|p')

  for i in {1..30}; do
    # Usar nc (netcat) para verificar si el puerto est√° abierto
    # Es m√°s confiable que redis-cli en algunos entornos
    if nc -z "$REDIS_HOST" "$REDIS_PORT" 2>/dev/null; then
      echo "‚úÖ Redis est√° listo y aceptando conexiones"
      return 0
    fi

    echo "   Intento $i/30... Redis a√∫n no est√° listo"
    sleep 1
  done

  echo ""
  echo "‚ùå ERROR CR√çTICO: Redis no respondi√≥ despu√©s de 30 segundos"
  echo "   Verifica que el servicio redis est√© corriendo:"
  echo "   docker compose ps redis"
  echo ""
  exit 1
}

# ------------------------------------------
# L√ìGICA PRINCIPAL
# ------------------------------------------
# Solo preparar la base de datos si el comando es "rails server"
# Esto evita ejecutar migraciones cuando haces:
# docker compose run web rails console
# docker compose run web bash
# etc.

if [ "${1}" == "./bin/rails" ] && [ "${2}" == "server" ]; then
  # Banner de inicio
  echo ""
  echo "================================================"
  echo "üöÄ INICIANDO RUTISERVICE APP"
  echo "================================================"
  echo ""
  echo "üìã Configuraci√≥n del entorno:"
  echo "   - RAILS_ENV:    ${RAILS_ENV:-not set}"
  echo "   - DATABASE_URL: ${DATABASE_URL:0:50}..." # Solo primeros 50 caracteres
  echo "   - REDIS_URL:    ${REDIS_URL:-not set}"
  echo ""
  echo "‚ÑπÔ∏è  Docker Compose ya verific√≥ que PostgreSQL y Redis est√°n listos"
  echo "   (gracias a depends_on con condition: service_healthy)"
  echo ""

  # Skip db:prepare in staging/production - run manually:
  # docker compose -f docker-compose.staging.yml exec web rails db:create db:migrate
  if [ "${RAILS_ENV}" != "staging" ] && [ "${RAILS_ENV}" != "production" ]; then
    echo "================================================"
    echo "üìä Preparando base de datos..."
    echo "================================================"
    echo ""

    # rails db:prepare hace:
    # 1. Crea la DB si no existe (rails db:create)
    # 2. Ejecuta migraciones pendientes (rails db:migrate)
    # 3. Carga el schema si es DB nueva (rails db:schema:load)
    # Es idempotente: puedes ejecutarlo m√∫ltiples veces sin problemas
    ./bin/rails db:prepare

    echo ""
    echo "‚úÖ Base de datos lista"
    echo ""
  else
    echo "‚ÑπÔ∏è  En staging/production, ejecuta manualmente:"
    echo "   docker compose exec web rails db:create db:migrate"
    echo ""
  fi

  echo "================================================"
  echo "üåê Iniciando servidor Rails..."
  echo "================================================"
  echo ""
  echo "   La aplicaci√≥n estar√° disponible en:"
  echo "   http://localhost:3000"
  echo ""
  echo "   Para ver logs en tiempo real:"
  echo "   docker compose logs -f web"
  echo ""
  echo "   Para abrir consola Rails:"
  echo "   docker compose exec web rails console"
  echo ""
  echo "================================================"
  echo ""
fi

# ------------------------------------------
# EJECUTAR COMANDO ORIGINAL
# ------------------------------------------
# exec reemplaza el proceso actual con el comando especificado
# "${@}" expande todos los argumentos pasados al script
# Ejemplos:
# - Si CMD es ["./bin/rails", "server"], ejecuta: ./bin/rails server
# - Si ejecutas: docker compose run web bash, ejecuta: bash

exec "${@}"
