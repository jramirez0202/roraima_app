// idb@8.0.3 downloaded from https://ga.jspm.io/npm:idb@8.0.3/build/index.js

const e=(e,t)=>t.some((t=>e instanceof t));let t;let n;function r(){return t||(t=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function o(){return n||(n=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const s=new WeakMap;const i=new WeakMap;const c=new WeakMap;function a(e){const t=new Promise(((t,n)=>{const r=()=>{e.removeEventListener("success",o);e.removeEventListener("error",s)};const o=()=>{t(D(e.result));r()};const s=()=>{n(e.error);r()};e.addEventListener("success",o);e.addEventListener("error",s)}));c.set(t,e);return t}function u(e){if(s.has(e))return;const t=new Promise(((t,n)=>{const r=()=>{e.removeEventListener("complete",o);e.removeEventListener("error",s);e.removeEventListener("abort",s)};const o=()=>{t();r()};const s=()=>{n(e.error||new DOMException("AbortError","AbortError"));r()};e.addEventListener("complete",o);e.addEventListener("error",s);e.addEventListener("abort",s)}));s.set(e,t)}let d={get(e,t,n){if(e instanceof IDBTransaction){if(t==="done")return s.get(e);if(t==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return D(e[t])},set(e,t,n){e[t]=n;return true},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")||t in e}};function f(e){d=e(d)}function l(e){return o().includes(e)?function(...t){e.apply(I(this),t);return D(this.request)}:function(...t){return D(e.apply(I(this),t))}}function p(t){if(typeof t==="function")return l(t);t instanceof IDBTransaction&&u(t);return e(t,r())?new Proxy(t,d):t}function D(e){if(e instanceof IDBRequest)return a(e);if(i.has(e))return i.get(e);const t=p(e);if(t!==e){i.set(e,t);c.set(t,e)}return t}const I=e=>c.get(e)
/**
 * Open a database.
 *
 * @param name Name of the database.
 * @param version Schema version.
 * @param callbacks Additional callbacks.
 */;function v(e,t,{blocked:n,upgrade:r,blocking:o,terminated:s}={}){const i=indexedDB.open(e,t);const c=D(i);r&&i.addEventListener("upgradeneeded",(e=>{r(D(i.result),e.oldVersion,e.newVersion,D(i.transaction),e)}));n&&i.addEventListener("blocked",(e=>n(e.oldVersion,e.newVersion,e)));c.then((e=>{s&&e.addEventListener("close",(()=>s()));o&&e.addEventListener("versionchange",(e=>o(e.oldVersion,e.newVersion,e)))})).catch((()=>{}));return c}
/**
 * Delete a database.
 *
 * @param name Name of the database.
 */function B(e,{blocked:t}={}){const n=indexedDB.deleteDatabase(e);t&&n.addEventListener("blocked",(e=>t(e.oldVersion,e)));return D(n).then((()=>{}))}const g=["get","getKey","getAll","getAllKeys","count"];const y=["put","add","delete","clear"];const b=new Map;function h(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t==="string"))return;if(b.get(t))return b.get(t);const n=t.replace(/FromIndex$/,"");const r=t!==n;const o=y.includes(n);if(!(n in(r?IDBIndex:IDBObjectStore).prototype)||!(o||g.includes(n)))return;const s=async function(e,...t){const s=this.transaction(e,o?"readwrite":"readonly");let i=s.store;r&&(i=i.index(t.shift()));return(await Promise.all([i[n](...t),o&&s.done]))[0]};b.set(t,s);return s}f((e=>({...e,get:(t,n,r)=>h(t,n)||e.get(t,n,r),has:(t,n)=>!!h(t,n)||e.has(t,n)})));const w=["continue","continuePrimaryKey","advance"];const m={};const E=new WeakMap;const L=new WeakMap;const x={get(e,t){if(!w.includes(t))return e[t];let n=m[t];n||(n=m[t]=function(...e){E.set(this,L.get(this)[t](...e))});return n}};async function*k(...e){let t=this;t instanceof IDBCursor||(t=await t.openCursor(...e));if(!t)return;t;const n=new Proxy(t,x);L.set(n,t);c.set(n,I(t));while(t){yield n;t=await(E.get(n)||t.continue());E.delete(n)}}function S(t,n){return n===Symbol.asyncIterator&&e(t,[IDBIndex,IDBObjectStore,IDBCursor])||n==="iterate"&&e(t,[IDBIndex,IDBObjectStore])}f((e=>({...e,get(t,n,r){return S(t,n)?k:e.get(t,n,r)},has(t,n){return S(t,n)||e.has(t,n)}})));export{B as deleteDB,v as openDB,I as unwrap,D as wrap};

